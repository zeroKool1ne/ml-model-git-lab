# -*- coding: utf-8 -*-
"""eda_borrower.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xvxr8HvPPx6PW8OzzI-Ki4Z4_UV3SCBZ
"""

import pandas as pd
from typing import Dict, Any, List, Callable

BORROWER_COLS = [
    "id", "member_id",
    "emp_title", "emp_length",
    "home_ownership",
    "annual_inc", "annual_inc_joint",
    "verification_status", "verification_status_joint",
    "zip_code", "addr_state",
    "purpose", "title", "desc",
    "issue_d", "pymnt_plan", "policy_code",
    "url",
]

class BorrowerProfileEDA:
    def __init__(self, df: pd.DataFrame, target_col: str = "loan_status"):
        """
        Store the full DataFrame and the name of the target column.
        """
        self.df = df
        self.target_col = target_col

    def structure_summary(self) -> pd.DataFrame:
        # Create empty list
        rows = []
        # Loop over BORROWER_COLS and if empty fields fill with dict
        for col in BORROWER_COLS:
            if col not in  self.df.columns:
                rows.append({
                    "column" : col,
                    "dtype" : None,
                    "n_missing" : None,
                    "missing_pct" : None,
                    "n_unique" : None
            })
            else:
                # create series
                s = self.df[col]

                # fill series with asked information about data
                rows.append({
                    "column" : col,
                    "dtype" : s.dtype,
                    "n_missing" : s.isna().sum(),
                    "missing_pct" : (s.isna().mean() *100),
                    "n_unique" : s.nunique(dropna=True)
            })
        # return Dataframe with Information about the data
        return pd.DataFrame(rows)

    def income_summary(self) -> pd.DataFrame:
        #provide information about two explicit columns via describe().T
        return self.df[["annual_inc", "annual_inc_joint"]].describe().T


    def categorical_freqs(self, max_levels: int = 10) -> Dict[str, pd.Series]:
        # create variable for list of columns
        cat_cols = ['home_ownership', 'addr_state', 'purpose']
        # create empty dict to return info
        result = {}
        # loop over specified columns and write value_counts in dict result
        for col in cat_cols:
          if col in self.df.columns:
            result[col] = self.df[col].value_counts().head(max_levels)
          else:
            result[col] = None
        # return dict with result
        return result


    def default_rate_by_category(self, col: str) -> pd.Series:
        return self.df.groupby(col)[self.target_col].mean()

def borrower_eda_steps(eda: BorrowerProfileEDA) -> Dict[str, Callable[[], Any]]:

    return {
        "structure": eda.structure_summary,
        "income": eda.income_summary,
        "freqs": lambda: eda.categorical_freqs(max_levels=10),
        "default_by_home_ownership": lambda: eda.default_rate_by_category("home_ownership"),
        "default_by_purpose": lambda: eda.default_rate_by_category("purpose"),
    }


def run_borrower_eda_pipeline(eda: BorrowerProfileEDA) -> Dict[str, Any]:
    steps = borrower_eda_steps(eda)
    results = {}

    for name, func in steps.items():
        results[name] = func()  # call the stored function

    return results