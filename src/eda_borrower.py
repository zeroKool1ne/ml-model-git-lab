# -*- coding: utf-8 -*-
"""eda_borrower.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Xvxr8HvPPx6PW8OzzI-Ki4Z4_UV3SCBZ
"""

import pandas as pd
from typing import Dict, Any, List, Callable

BORROWER_COLS = [
    "id", "member_id",
    "emp_title", "emp_length",
    "home_ownership",
    "annual_inc", "annual_inc_joint",
    "verification_status", "verification_status_joint",
    "zip_code", "addr_state",
    "purpose", "title", "desc",
    "issue_d", "pymnt_plan", "policy_code",
    "url",
]

class BorrowerProfileEDA:
    def __init__(self, df: pd.DataFrame, target_col: str = "loan_status"):
        """
        Store the full DataFrame and the name of the target column.
        """
        self.df = df
        self.target_col = target_col

    def structure_summary(self) -> pd.DataFrame:
        """
        Return a DataFrame with one row per column in BORROWER_COLS:
        - column: column name
        - dtype: pandas dtype
        - n_missing: number of missing values
        - missing_pct: percentage of missing values
        - n_unique: number of unique values
        - goal is to create a function that tells me all the information above about the columns in borrower_cols
        - if I dont find any data return none
        """

        rows = []

        for col in BORROWER_COLS:
            if col not in  self.df.columns:
                rows.append({
                    "column" : col,
                    "dtype" : None,
                    "n_missing" : None,
                    "missing_pct" : None,
                    "n_unique" : None
            })
            else:
                s = self.df[col]

                rows.append({
                    "column" : col,
                    "dtype" : s.dtype,
                    "n_missing" : s.isna().sum(),
                    "missing_pct" : (s.isna().mean() *100),
                    "n_unique" : s.nunique(dropna=True)
            })
        return pd.DataFrame(rows)

    def income_summary(self) -> pd.DataFrame:
        """
        Return basic stats (count, mean, std, min, max, quartiles)
        for:
        - annual_inc
        - annual_inc_joint

        Use df[["annual_inc", "annual_inc_joint"]].describe().T
        or equivalent.
        """

        return self.df[["annual_inc", "annual_inc_joint"]].describe().T

    def categorical_freqs(self, max_levels: int = 10) -> Dict[str, pd.Series]:
        """
        For important categorical borrower columns (e.g. home_ownership,
        addr_state, purpose), return a dict:

            {
              "home_ownership": Series of top levels,
              "addr_state": Series of top levels,
              ...
            }

        Each Series should be the result of value_counts().head(max_levels).
        """
        cat_cols = ['home_ownership', 'addr_state', 'purpose']

        result = {}

        for col in cat_cols:
          if col in self.df.columns:
            result[col] = self.df[col].value_counts.head(max_levels)
          else:
            result[col] = None

        return result

    def default_rate_by_category(self, col: str) -> pd.Series:
        """
        For a given categorical column (e.g. 'home_ownership' or 'purpose'),
        compute the default rate per category.

        Default rate = mean of self.target_col for each category.
        Return a pandas Series indexed by category, with values in [0, 1].
        """
        return self.df.groupby(col)[self.target_col].mean()